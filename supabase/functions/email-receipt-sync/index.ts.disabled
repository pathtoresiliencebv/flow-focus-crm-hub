import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";
import Imap from "npm:imap";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface EmailSettings {
  id: string;
  email_address: string;
  imap_host: string;
  imap_port: number;
  imap_username: string;
  imap_password: string;
  last_sync_at: string | null;
}

interface EmailMessage {
  uid: number;
  subject: string;
  from: string;
  date: Date;
  attachments: Array<{
    filename: string;
    content: Uint8Array;
    contentType: string;
  }>;
}

async function processEmailAttachment(
  supabase: any,
  attachment: { filename: string; content: Uint8Array; contentType: string },
  fromEmail: string
) {
  try {
    console.log(`Processing attachment: ${attachment.filename} from ${fromEmail}`);
    
    // Check if it's an image or PDF
    const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'application/pdf'];
    if (!validTypes.includes(attachment.contentType)) {
      console.log(`Skipping non-receipt file type: ${attachment.contentType}`);
      return;
    }

    // Generate unique filename
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const extension = attachment.filename.split('.').pop() || 'bin';
    const fileName = `receipt-${timestamp}-${Math.random().toString(36).substring(2)}.${extension}`;
    const filePath = `receipts/${fileName}`;

    // Upload to Supabase storage
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('receipts')
      .upload(filePath, attachment.content, {
        contentType: attachment.contentType,
        upsert: false
      });

    if (uploadError) {
      console.error('Error uploading file:', uploadError);
      return;
    }

    console.log(`File uploaded successfully: ${filePath}`);

    // Get the public URL
    const { data: urlData } = supabase.storage
      .from('receipts')
      .getPublicUrl(filePath);

    // Insert into bonnetjes table
    const { data: bonnetjeData, error: bonnetjeError } = await supabase
      .from('bonnetjes')
      .insert({
        sender: fromEmail,
        file_name: attachment.filename,
        file_path: urlData.publicUrl
      })
      .select()
      .single();

    if (bonnetjeError) {
      console.error('Error inserting bonnetje:', bonnetjeError);
      return;
    }

    console.log(`Bonnetje created successfully:`, bonnetjeData);

    // Create notification for administrators
    const { data: admins } = await supabase
      .from('profiles')
      .select('id')
      .eq('role', 'Administrator');

    if (admins && admins.length > 0) {
      const notifications = admins.map((admin: any) => ({
        user_id: admin.id,
        title: 'Nieuw bonnetje ontvangen',
        message: `Een nieuw bonnetje is ontvangen van ${fromEmail}: ${attachment.filename}`,
        type: 'receipt',
        reference_type: 'bonnetje',
        reference_id: bonnetjeData.id
      }));

      await supabase
        .from('user_notifications')
        .insert(notifications);

      console.log(`Notifications sent to ${admins.length} administrators`);
    }

  } catch (error) {
    console.error('Error processing attachment:', error);
  }
}

async function syncEmailsViaIMAP(emailSettings: EmailSettings, supabase: any) {
  return new Promise((resolve, reject) => {
    console.log(`Starting IMAP sync for ${emailSettings.email_address}`);

    const imap = new Imap({
      user: emailSettings.imap_username,
      password: emailSettings.imap_password,
      host: emailSettings.imap_host,
      port: emailSettings.imap_port,
      tls: true,
      tlsOptions: { rejectUnauthorized: false }
    });

    imap.once('ready', () => {
      console.log('Connected to IMAP server');
      
      imap.openBox('INBOX', false, (err: any, box: any) => {
        if (err) {
          console.error('Error opening INBOX:', err);
          reject(err);
          return;
        }
        
        // Calculate date filter (last sync or last 24 hours)
        const sinceDate = emailSettings.last_sync_at 
          ? new Date(emailSettings.last_sync_at)
          : new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours ago

        console.log(`Searching for emails since: ${sinceDate.toISOString()}`);

        // Search for recent emails
        const searchCriteria = [
          'UNSEEN', // Only unread emails
          ['SINCE', sinceDate]
        ];

        imap.search(searchCriteria, (err: any, results: number[]) => {
          if (err) {
            console.error('Search error:', err);
            reject(err);
            return;
          }

          console.log(`Found ${results.length} new messages`);
          
          if (results.length === 0) {
            imap.end();
            resolve({
              success: true,
              emailsProcessed: 0,
              attachmentsProcessed: 0
            });
            return;
          }

          let processedCount = 0;
          let attachmentCount = 0;

          // Fetch message details
          const fetch = imap.fetch(results, {
            bodies: 'HEADER.FIELDS (FROM TO SUBJECT DATE)',
            struct: true
          });

          fetch.on('message', (msg: any, seqno: number) => {
            let header: any = {};
            let attachments: Array<{filename: string; content: Buffer; contentType: string}> = [];

            msg.on('body', (stream: any, info: any) => {
              let buffer = '';
              stream.on('data', (chunk: any) => {
                buffer += chunk.toString('ascii');
              });
              stream.once('end', () => {
                header = Imap.parseHeader(buffer);
                console.log(`Message ${seqno}: ${header.subject?.[0] || 'No Subject'} from ${header.from?.[0] || 'Unknown'}`);
              });
            });

            msg.once('attributes', (attrs: any) => {
              if (attrs.struct) {
                // Process message structure to find attachments
                function processStruct(struct: any[], path: string = '') {
                  struct.forEach((part: any, index: number) => {
                    const partPath = path ? `${path}.${index + 1}` : `${index + 1}`;
                    
                    if (part.disposition?.type === 'attachment' || part.type === 'application' || part.type === 'image') {
                      const filename = part.disposition?.params?.filename || 
                                     part.params?.name || 
                                     `attachment_${Date.now()}_${index}`;
                      
                      const contentType = part.type && part.subtype 
                        ? `${part.type.toLowerCase()}/${part.subtype.toLowerCase()}`
                        : 'application/octet-stream';

                      // Only process image and PDF files
                      const validTypes = ['image/jpeg', 'image/png', 'image/jpg', 'application/pdf'];
                      if (validTypes.includes(contentType)) {
                        console.log(`Found attachment: ${filename} (${contentType})`);
                        
                        // Fetch attachment content
                        const attachmentFetch = imap.fetch([seqno], {
                          bodies: [partPath],
                          struct: false
                        });
                        
                        attachmentFetch.on('message', (attachMsg: any) => {
                          attachMsg.on('body', (attachStream: any) => {
                            const chunks: Buffer[] = [];
                            attachStream.on('data', (chunk: Buffer) => {
                              chunks.push(chunk);
                            });
                            attachStream.once('end', () => {
                              let content = Buffer.concat(chunks);
                              
                              // Handle base64 encoding if needed
                              if (part.encoding && part.encoding.toLowerCase() === 'base64') {
                                content = Buffer.from(content.toString(), 'base64');
                              }
                              
                              attachments.push({
                                filename,
                                content,
                                contentType
                              });
                            });
                          });
                        });
                      }
                    } else if (Array.isArray(part)) {
                      processStruct(part, partPath);
                    }
                  });
                }

                if (Array.isArray(attrs.struct)) {
                  processStruct(attrs.struct);
                }
              }
            });

            msg.once('end', async () => {
              // Process attachments after message is fully processed
              const fromEmail = header.from?.[0] || 'unknown@unknown.com';
              
              for (const attachment of attachments) {
                try {
                  await processEmailAttachment(supabase, attachment, fromEmail);
                  attachmentCount++;
                } catch (error) {
                  console.error(`Error processing attachment ${attachment.filename}:`, error);
                }
              }

              // Mark message as read
              imap.addFlags([seqno], ['\\Seen'], (err: any) => {
                if (err) console.error('Error marking message as read:', err);
              });

              processedCount++;
              
              // Check if all messages are processed
              if (processedCount === results.length) {
                imap.end();
              }
            });
          });

          fetch.once('error', (err: any) => {
            console.error('Fetch error:', err);
            imap.end();
            reject(err);
          });

          fetch.once('end', () => {
            console.log('Fetch completed');
            setTimeout(() => {
              // Update sync status
              supabase
                .from('user_email_settings')
                .update({
                  last_sync_at: new Date().toISOString(),
                  sync_status: 'completed',
                  is_syncing: false
                })
                .eq('id', emailSettings.id)
                .then(() => {
                  console.log(`IMAP sync completed: ${processedCount} emails processed, ${attachmentCount} attachments found`);
                  resolve({
                    success: true,
                    emailsProcessed: processedCount,
                    attachmentsProcessed: attachmentCount
                  });
                });
            }, 2000); // Wait 2 seconds for all attachments to process
          });
        });
      });
    });

    imap.once('error', (err: any) => {
      console.error('IMAP connection error:', err);
      
      // Update error status
      supabase
        .from('user_email_settings')
        .update({
          sync_status: 'error',
          sync_error_message: err.message,
          is_syncing: false
        })
        .eq('id', emailSettings.id)
        .then(() => {
          reject(err);
        });
    });

    imap.once('end', () => {
      console.log('IMAP connection ended');
    });

    imap.connect();
  });
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('Email receipt sync started');

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { email } = await req.json();

    // Get email settings for bonnetjes account
    const { data: emailSettings, error: settingsError } = await supabase
      .from('user_email_settings')
      .select('*')
      .eq('email_address', email || 'bonnetjes@smanscrm.nl')
      .eq('is_active', true)
      .single();

    if (settingsError || !emailSettings) {
      console.error('Email settings not found:', settingsError);
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Email settings not found' 
        }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Check if already syncing
    if (emailSettings.is_syncing) {
      console.log('Sync already in progress, skipping');
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Sync already in progress' 
        }),
        { 
          status: 429, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Mark as syncing
    await supabase
      .from('user_email_settings')
      .update({ is_syncing: true, sync_status: 'running' })
      .eq('id', emailSettings.id);

    // Perform IMAP sync
    const result = await syncEmailsViaIMAP(emailSettings, supabase);

    console.log('Email receipt sync completed successfully');

    return new Response(
      JSON.stringify(result),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Email receipt sync error:', error);
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message 
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});