
import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Plus, Save } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { QuoteBlockForm } from './QuoteBlockForm';
import { MultiBlockQuotePreview } from './MultiBlockQuotePreview';
import { SignatureCanvas } from '../SignatureCanvas';
import { CustomerQuickAdd } from '../CustomerQuickAdd';
import { QuoteBlock, Quote } from '@/types/quote';
import { supabase } from "@/integrations/supabase/client";

const formSchema = z.object({
  customer: z.string().min(1, { message: "Selecteer een klant" }),
  quoteNumber: z.string().min(1, { message: "Offertenummer is verplicht" }),
  date: z.string().min(1, { message: "Datum is verplicht" }),
  validUntil: z.string().min(1, { message: "Geldig tot datum is verplicht" }),
  project: z.string().optional(),
  message: z.string().optional(),
});

interface MultiBlockQuoteFormProps {
  onClose: () => void;
  customers: Array<{ id: string; name: string; email?: string }>;
  projects?: Array<{ id: string; title: string; value: string; customer: string }>;
}

export const MultiBlockQuoteForm: React.FC<MultiBlockQuoteFormProps> = ({
  onClose,
  customers,
  projects
}) => {
  const { toast } = useToast();
  const [blocks, setBlocks] = useState<QuoteBlock[]>([
    {
      id: crypto.randomUUID(),
      title: 'Hoofdwerkzaamheden',
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: 0
    }
  ]);
  const [adminSignature, setAdminSignature] = useState('');
  const [saving, setSaving] = useState(false);
  const [updateCounter, setUpdateCounter] = useState(0);
  const [previewKey, setPreviewKey] = useState(0);
  const [showCustomerAdd, setShowCustomerAdd] = useState(false);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      customer: "",
      quoteNumber: "", // Will be generated by database function
      date: new Date().toISOString().split('T')[0],
      validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      project: "",
      message: "",
    },
  });

  // Generate quote number on mount
  useEffect(() => {
    const generateQuoteNumber = async () => {
      try {
        const { data, error } = await supabase.rpc('generate_quote_number');
        if (data && !error) {
          form.setValue('quoteNumber', data);
        }
      } catch (err) {
        console.error('Error generating quote number:', err);
        // Fallback to timestamp-based number
        form.setValue('quoteNumber', `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`);
      }
    };
    generateQuoteNumber();
  }, [form]);

  // Remove automatic watching to prevent false impression of auto-save
  // const watchedFields = form.watch();

  const forcePreviewUpdate = useCallback(() => {
    console.log('MultiBlockQuoteForm: Forcing preview update');
    setUpdateCounter(prev => prev + 1);
    setPreviewKey(prev => prev + 1);
  }, []);

  const addBlock = useCallback(() => {
    const newBlock: QuoteBlock = {
      id: crypto.randomUUID(),
      title: `Blok ${blocks.length + 1}`,
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: blocks.length
    };
    console.log('MultiBlockQuoteForm: Adding new block:', newBlock);
    setBlocks(prevBlocks => {
      const newBlocks = [...prevBlocks, newBlock];
      console.log('MultiBlockQuoteForm: New blocks state:', newBlocks);
      return newBlocks;
    });
    forcePreviewUpdate();
  }, [blocks.length, forcePreviewUpdate]);

  const updateBlock = useCallback((index: number, updatedBlock: QuoteBlock) => {
    console.log('MultiBlockQuoteForm: Updating block at index', index, 'with block:', updatedBlock);
    console.log('MultiBlockQuoteForm: Updated block items:', updatedBlock.items);
    
    setBlocks(prevBlocks => {
      if (index < 0 || index >= prevBlocks.length) {
        console.error('Invalid block index:', index);
        return prevBlocks;
      }
      
      const newBlocks = [...prevBlocks];
      newBlocks[index] = { 
        ...updatedBlock,
        id: prevBlocks[index].id, // Preserve original ID
        order_index: prevBlocks[index].order_index // Preserve order
      };
      
      console.log('MultiBlockQuoteForm: New blocks state after update:', newBlocks);
      console.log('MultiBlockQuoteForm: Updated block items:', newBlocks[index].items);
      return newBlocks;
    });
    
    // Force re-render after state update
    setTimeout(() => forcePreviewUpdate(), 0);
  }, [forcePreviewUpdate]);

  const deleteBlock = useCallback((index: number) => {
    if (blocks.length > 1) {
      console.log('MultiBlockQuoteForm: Deleting block at index:', index);
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.filter((_, i) => i !== index);
        console.log('MultiBlockQuoteForm: Blocks after deletion:', newBlocks);
        return newBlocks;
      });
      forcePreviewUpdate();
    }
  }, [blocks.length, forcePreviewUpdate]);

  const handleDragEnd = useCallback((result: DropResult) => {
    if (!result.destination) {
      return;
    }

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) {
      return;
    }

    setBlocks(prevBlocks => {
      const newBlocks = Array.from(prevBlocks);
      const [reorderedBlock] = newBlocks.splice(sourceIndex, 1);
      newBlocks.splice(destinationIndex, 0, reorderedBlock);
      
      // Update order indices
      return newBlocks.map((block, index) => ({
        ...block,
        order_index: index
      }));
    });
    
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const totalAmount = useMemo(() => {
    const total = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total amount:', total, 'from blocks:', blocks);
    return total;
  }, [blocks, updateCounter]);

  const totalVAT = useMemo(() => {
    const vat = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total VAT:', vat, 'from blocks:', blocks);
    return vat;
  }, [blocks, updateCounter]);

  const grandTotal = useMemo(() => {
    const grand = totalAmount + totalVAT;
    console.log('MultiBlockQuoteForm: Calculated grand total:', grand);
    return grand;
  }, [totalAmount, totalVAT]);

  // Effect to monitor blocks changes for debugging
  useEffect(() => {
    console.log('MultiBlockQuoteForm: Blocks state changed:', blocks);
    console.log('MultiBlockQuoteForm: Total calculations - Amount:', totalAmount, 'VAT:', totalVAT, 'Grand:', grandTotal);
  }, [blocks, totalAmount, totalVAT, grandTotal]);

  const onSubmit = useCallback(async (values: z.infer<typeof formSchema>) => {
    setSaving(true);
    
    // Get the current blocks state at the time of submission
    setBlocks(currentBlocks => {
      console.log('MultiBlockQuoteForm: Current blocks at submit time:', JSON.stringify(currentBlocks, null, 2));
      
      // Continue with submission using current blocks
      (async () => {
        try {
          const customer = customers.find(c => c.id === values.customer);
          const project = projects?.find(p => p.id === values.project);

          // Generate public token
          const { data: tokenData, error: tokenError } = await supabase
            .rpc('generate_quote_public_token');

          if (tokenError) {
            console.error('Error generating token:', tokenError);
            toast({
              title: "Fout",
              description: "Kon geen publieke link genereren.",
              variant: "destructive",
            });
            setSaving(false);
            return;
          }

          // Get the current quote number if empty
          let quoteNumber = values.quoteNumber;
          if (!quoteNumber) {
            const { data: generatedNumber } = await supabase.rpc('generate_quote_number');
            quoteNumber = generatedNumber || `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`;
          }

          // Calculate totals from current blocks
          const currentTotalAmount = currentBlocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
          const currentTotalVAT = currentBlocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
          const currentGrandTotal = currentTotalAmount + currentTotalVAT;

          console.log('MultiBlockQuoteForm: Saving blocks to database:', {
            blocks: currentBlocks,
            totalAmount: currentTotalAmount,
            totalVAT: currentTotalVAT,
            grandTotal: currentGrandTotal
          });

          // Save quote to database with current block structure
          const { data, error } = await supabase
            .from('quotes')
            .insert({
              quote_number: quoteNumber,
              customer_name: customer?.name || '',
              customer_email: customer?.email || '',
              project_title: project?.title || '',
              quote_date: values.date,
              valid_until: values.validUntil,
              message: values.message || '',
              items: JSON.parse(JSON.stringify(currentBlocks)) as any, // Save blocks as JSON
              subtotal: currentTotalAmount,
              vat_amount: currentTotalVAT,
              total_amount: currentGrandTotal,
              status: 'concept',
              public_token: tokenData,
              admin_signature_data: adminSignature || null
            })
            .select()
            .single();

          if (error) {
            console.error('Error saving quote:', error);
            toast({
              title: "Fout bij opslaan",
              description: "De offerte kon niet worden opgeslagen.",
              variant: "destructive",
            });
            setSaving(false);
            return;
          }

          toast({
            title: "Offerte opgeslagen",
            description: `Offerte ${quoteNumber} is succesvol opgeslagen.`,
          });

          onClose();
        } catch (error) {
          console.error('Error:', error);
          toast({
            title: "Fout",
            description: "Er is een onverwachte fout opgetreden.",
            variant: "destructive",
          });
        } finally {
          setSaving(false);
        }
      })();

      return currentBlocks; // Return the same blocks, no change needed
    });
  }, [customers, projects, adminSignature, toast, onClose]);

  const handleFormSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('MultiBlockQuoteForm: Form submitted - this should only happen when saving the quote');
    form.handleSubmit(onSubmit)();
  }, [form, onSubmit]);

  // Get current form values only when needed
  const currentFormValues = form.getValues();
  
  const filteredProjects = projects?.filter(project => {
    const selectedCustomer = customers.find(c => c.id === currentFormValues.customer);
    return selectedCustomer && project.customer === selectedCustomer.name;
  }) || [];

  const handleCustomerAdded = (customerId: string) => {
    form.setValue('customer', customerId);
    setShowCustomerAdd(false);
  };

  // Create preview quote object - only update when blocks change, not on every form field change
  const previewQuote: Quote = useMemo(() => {
    const formValues = form.getValues();
    const quote = {
      quote_number: formValues.quoteNumber || `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`,
      customer_name: customers.find(c => c.id === formValues.customer)?.name || '',
      customer_email: customers.find(c => c.id === formValues.customer)?.email || '',
      project_title: projects?.find(p => p.id === formValues.project)?.title || '',
      quote_date: formValues.date || new Date().toISOString().split('T')[0],
      valid_until: formValues.validUntil || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      message: formValues.message || '',
      blocks: JSON.parse(JSON.stringify(blocks)), // Deep copy to ensure re-render
      total_amount: totalAmount,
      total_vat_amount: totalVAT,
      status: 'concept' as const,
      admin_signature_data: adminSignature
    };
    console.log('MultiBlockQuoteForm: Created preview quote with updateCounter:', updateCounter, 'previewKey:', previewKey, quote);
    return quote;
  }, [customers, projects, blocks, totalAmount, totalVAT, adminSignature, updateCounter, previewKey]);

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 max-h-[80vh] overflow-hidden">
      {/* Left side - Form */}
      <div className="space-y-4 overflow-y-auto pr-2">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium">Nieuwe offerte - Meerdere blokken</h3>
          <div className="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-lg text-sm font-medium">
            ⚠️ Concept - Niet opgeslagen
          </div>
        </div>

        <Form {...form}>
          <form onSubmit={handleFormSubmit} className="space-y-4">
            {/* Basic Form Fields */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Offerte Gegevens</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="grid grid-cols-1 gap-4">
                  <FormField
                    control={form.control}
                    name="customer"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Klant *</FormLabel>
                        <div className="flex gap-2">
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger>
                                <SelectValue placeholder="Selecteer klant" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {customers.map((customer) => (
                                <SelectItem key={customer.id} value={customer.id}>
                                  {customer.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => setShowCustomerAdd(true)}
                            className="shrink-0"
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {showCustomerAdd && (
                    <CustomerQuickAdd
                      onCustomerAdded={handleCustomerAdded}
                      onCancel={() => setShowCustomerAdd(false)}
                    />
                  )}

                  <FormField
                    control={form.control}
                    name="project"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Project (optioneel)</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Selecteer project" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {filteredProjects.map((project) => (
                              <SelectItem key={project.id} value={project.id}>
                                {project.title}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="grid grid-cols-3 gap-4">
                  <FormField
                    control={form.control}
                    name="quoteNumber"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Offertenummer *</FormLabel>
                        <FormControl>
                          <Input {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="date"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Datum *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="validUntil"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Geldig tot *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="message"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Bericht (optioneel)</FormLabel>
                      <FormControl>
                        <Textarea {...field} placeholder="Voeg een persoonlijk bericht toe..." />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            {/* Quote Blocks */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>Offerte Blokken</CardTitle>
                  <Button 
                    type="button" 
                    onClick={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      addBlock();
                    }} 
                    size="sm"
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Blok toevoegen
                  </Button>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                <DragDropContext onDragEnd={handleDragEnd}>
                  <Droppable droppableId="quote-blocks">
                    {(provided) => (
                      <div 
                        {...provided.droppableProps}
                        ref={provided.innerRef}
                        className="space-y-3"
                      >
                        {blocks.map((block, index) => (
                          <Draggable key={block.id} draggableId={block.id} index={index}>
                            {(provided, snapshot) => (
                              <div
                                ref={provided.innerRef}
                                {...provided.draggableProps}
                                className={`${snapshot.isDragging ? 'opacity-50' : ''}`}
                              >
                                <QuoteBlockForm
                                  key={`${block.id}-${updateCounter}-${previewKey}`}
                                  block={block}
                                  onUpdateBlock={(updatedBlock) => updateBlock(index, updatedBlock)}
                                  onDeleteBlock={() => deleteBlock(index)}
                                  canDelete={blocks.length > 1}
                                  dragHandleProps={provided.dragHandleProps}
                                />
                              </div>
                            )}
                          </Draggable>
                        ))}
                        {provided.placeholder}
                      </div>
                    )}
                  </Droppable>
                </DragDropContext>

                {/* Grand Total */}
                <Card className="bg-gray-50">
                  <CardContent className="p-3">
                    <div className="flex justify-end">
                      <div className="w-64 space-y-1">
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal excl. BTW:</span>
                          <span className="font-medium">€{totalAmount.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal BTW:</span>
                          <span className="font-medium">€{totalVAT.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between py-2 border-t-2 border-gray-300">
                          <span className="font-bold text-lg">Eindtotaal:</span>
                          <span className="font-bold text-lg text-smans-primary">
                            €{grandTotal.toFixed(2)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </CardContent>
            </Card>

            {/* Admin Signature */}
            <SignatureCanvas
              title="Uw handtekening (SMANS BV)"
              onSignature={setAdminSignature}
            />

            <div className="flex justify-end gap-2">
              <Button type="button" variant="outline" onClick={onClose}>
                Annuleren
              </Button>
              <Button type="submit" disabled={saving}>
                <Save className="h-4 w-4 mr-2" />
                {saving ? "Bezig met opslaan..." : "Offerte opslaan"}
              </Button>
            </div>
          </form>
        </Form>
      </div>

      {/* Right side - Live Preview */}
      <div className="overflow-y-auto pl-2">
        <div className="sticky top-0 bg-white z-10 pb-2 mb-4 border-b">
          <h4 className="font-medium text-gray-700">Live Preview</h4>
          <p className="text-xs text-yellow-600 font-medium">⚠️ Dit is alleen een preview - offerte wordt pas opgeslagen bij 'Offerte Opslaan'</p>
        </div>
        <MultiBlockQuotePreview key={previewKey} quote={previewQuote} />
      </div>
    </div>
  );
};
