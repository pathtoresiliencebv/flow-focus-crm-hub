
import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useNavigate } from 'react-router-dom';
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Plus, Save, BookmarkPlus } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { QuoteBlockForm } from './QuoteBlockForm';
import { MultiBlockQuotePreview } from './MultiBlockQuotePreview';
import { SignatureCanvas } from '../SignatureCanvas';
import { CustomerQuickAdd } from '../CustomerQuickAdd';
import { ProjectQuickAdd } from '../ProjectQuickAdd';
import { TemplateSelector } from './TemplateSelector';
import { PaymentTermsSelector, PaymentTerm } from './PaymentTermsSelector';
import { FileAttachmentsManager, QuoteAttachment } from './FileAttachmentsManager';
import { useCrmStore } from '@/hooks/useCrmStore';
import { useQuoteTemplates } from '@/hooks/useQuoteTemplates';
import { QuoteBlock, Quote } from '@/types/quote';
import { supabase } from "@/integrations/supabase/client";

const formSchema = z.object({
  customer: z.string().min(1, { message: "Selecteer een klant" }),
  customerEmail: z.string().email({ message: "Ongeldig email adres" }).optional().or(z.literal("")),
  quoteNumber: z.string().min(1, { message: "Offertenummer is verplicht" }),
  date: z.string().min(1, { message: "Datum is verplicht" }),
  validUntil: z.string().min(1, { message: "Geldig tot datum is verplicht" }),
  project: z.string().optional(),
  message: z.string().optional(),
}).refine((data) => {
  // Allow empty email or valid email
  if (!data.customerEmail || data.customerEmail === "") return true;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(data.customerEmail);
}, {
  message: "Ongeldig email adres",
  path: ["customerEmail"]
});

interface MultiBlockQuoteFormProps {
  onClose: () => void;
}

export const MultiBlockQuoteForm: React.FC<MultiBlockQuoteFormProps> = ({
  onClose
}) => {
  const { customers, projects, isLoading: crmLoading } = useCrmStore();
  const { toast } = useToast();
  const navigate = useNavigate();
  const [blocks, setBlocks] = useState<QuoteBlock[]>([
    {
      id: crypto.randomUUID(),
      title: 'Hoofdwerkzaamheden',
      type: 'product',
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: 0
    }
  ]);
  const [adminSignature, setAdminSignature] = useState('');
  const [saving, setSaving] = useState(false);
  const [updateCounter, setUpdateCounter] = useState(0);
  const [previewKey, setPreviewKey] = useState(0);
  const [showCustomerAdd, setShowCustomerAdd] = useState(false);
  const [showProjectAdd, setShowProjectAdd] = useState(false);
  const [savedQuote, setSavedQuote] = useState<Quote | null>(null);
  const [paymentTerms, setPaymentTerms] = useState<PaymentTerm[]>([
    { id: crypto.randomUUID(), percentage: 100, description: "Volledige betaling" }
  ]);
  const [attachments, setAttachments] = useState<QuoteAttachment[]>([]);
  
  const { templates, loading: templatesLoading, saveTemplate } = useQuoteTemplates();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      customer: "",
      customerEmail: "",
      quoteNumber: "", // Will be generated by database function
      date: new Date().toISOString().split('T')[0],
      validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      project: "",
      message: "",
    },
  });

  // Generate quote number on mount
  useEffect(() => {
    const generateQuoteNumber = async () => {
      try {
        const { data, error } = await supabase.rpc('generate_quote_number');
        if (data && !error) {
          form.setValue('quoteNumber', data);
        }
      } catch (err) {
        console.error('Error generating quote number:', err);
        // Fallback to timestamp-based number
        form.setValue('quoteNumber', `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`);
      }
    };
    generateQuoteNumber();
  }, [form]);

  // Remove automatic watching to prevent false impression of auto-save
  // const watchedFields = form.watch();

  const forcePreviewUpdate = useCallback(() => {
    console.log('MultiBlockQuoteForm: Forcing preview update');
    setUpdateCounter(prev => prev + 1);
    setPreviewKey(prev => prev + 1);
  }, []);

  const addBlock = useCallback(() => {
    const newBlock: QuoteBlock = {
      id: crypto.randomUUID(),
      title: `Blok ${blocks.length + 1}`,
      type: 'product',
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: blocks.length
    };
    console.log('MultiBlockQuoteForm: Adding new block:', newBlock);
    setBlocks(prevBlocks => {
      const newBlocks = [...prevBlocks, newBlock];
      console.log('MultiBlockQuoteForm: New blocks state:', newBlocks);
      return newBlocks;
    });
    forcePreviewUpdate();
  }, [blocks.length, forcePreviewUpdate]);

  const addTextBlock = useCallback(() => {
    const newTextBlock: QuoteBlock = {
      id: crypto.randomUUID(),
      title: 'Tekstblok',
      type: 'textblock',
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: blocks.length,
      content: ''
    };
    console.log('MultiBlockQuoteForm: Adding new text block:', newTextBlock);
    setBlocks(prevBlocks => {
      const newBlocks = [...prevBlocks, newTextBlock];
      console.log('MultiBlockQuoteForm: New blocks state:', newBlocks);
      return newBlocks;
    });
    forcePreviewUpdate();
  }, [blocks.length, forcePreviewUpdate]);

  const updateBlock = useCallback((index: number, updatedBlock: QuoteBlock) => {
    console.log('MultiBlockQuoteForm: Updating block at index', index, 'with block:', updatedBlock);
    console.log('MultiBlockQuoteForm: Updated block items:', updatedBlock.items);
    
    setBlocks(prevBlocks => {
      if (index < 0 || index >= prevBlocks.length) {
        console.error('Invalid block index:', index);
        return prevBlocks;
      }
      
      const newBlocks = [...prevBlocks];
      newBlocks[index] = { 
        ...updatedBlock,
        id: prevBlocks[index].id, // Preserve original ID
        order_index: prevBlocks[index].order_index // Preserve order
      };
      
      console.log('MultiBlockQuoteForm: New blocks state after update:', newBlocks);
      console.log('MultiBlockQuoteForm: Updated block items:', newBlocks[index].items);
      return newBlocks;
    });
    
    // Force re-render after state update
    setTimeout(() => forcePreviewUpdate(), 0);
  }, [forcePreviewUpdate]);

  const deleteBlock = useCallback((index: number) => {
    if (blocks.length > 1) {
      console.log('MultiBlockQuoteForm: Deleting block at index:', index);
      setBlocks(prevBlocks => {
        const newBlocks = prevBlocks.filter((_, i) => i !== index);
        console.log('MultiBlockQuoteForm: Blocks after deletion:', newBlocks);
        return newBlocks;
      });
      forcePreviewUpdate();
    }
  }, [blocks.length, forcePreviewUpdate]);

  const handleDragEnd = useCallback((result: DropResult) => {
    if (!result.destination) {
      return;
    }

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) {
      return;
    }

    setBlocks(prevBlocks => {
      const newBlocks = Array.from(prevBlocks);
      const [reorderedBlock] = newBlocks.splice(sourceIndex, 1);
      newBlocks.splice(destinationIndex, 0, reorderedBlock);
      
      // Update order indices
      return newBlocks.map((block, index) => ({
        ...block,
        order_index: index
      }));
    });
    
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const totalAmount = useMemo(() => {
    const total = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total amount:', total, 'from blocks:', blocks);
    return total;
  }, [blocks, updateCounter]);

  const totalVAT = useMemo(() => {
    const vat = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total VAT:', vat, 'from blocks:', blocks);
    return vat;
  }, [blocks, updateCounter]);

  const grandTotal = useMemo(() => {
    const grand = totalAmount + totalVAT;
    console.log('MultiBlockQuoteForm: Calculated grand total:', grand);
    return grand;
  }, [totalAmount, totalVAT]);

  // Effect to monitor blocks changes for debugging
  useEffect(() => {
    console.log('MultiBlockQuoteForm: Blocks state changed:', blocks);
    console.log('MultiBlockQuoteForm: Total calculations - Amount:', totalAmount, 'VAT:', totalVAT, 'Grand:', grandTotal);
  }, [blocks, totalAmount, totalVAT, grandTotal]);

  const saveAsDraft = useCallback(async (values: z.infer<typeof formSchema>, closeAfter: boolean = true, existingQuoteId?: string) => {
    setSaving(true);
    
    try {
      const customer = customers.find(c => c.id === values.customer);
      const project = projects?.find(p => p.id === values.project);
      
      const currentTotalAmount = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
      const currentTotalVAT = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
      const currentGrandTotal = currentTotalAmount + currentTotalVAT;
      
      const quoteData = {
        quote_number: values.quoteNumber,
        customer_name: customer?.name || '',
        customer_email: values.customerEmail || customer?.email || '',
        project_title: project?.title || '',
        quote_date: values.date,
        valid_until: values.validUntil,
        message: values.message || '',
        items: JSON.parse(JSON.stringify(blocks)),
        subtotal: currentTotalAmount,
        vat_amount: currentTotalVAT,
        total_amount: currentGrandTotal,
        status: 'concept',
        admin_signature_data: adminSignature || null,
        updated_at: new Date().toISOString()
      };

      let result;
      if (existingQuoteId) {
        // Update existing quote
        console.log('🔄 Updating existing quote:', existingQuoteId);
        result = await supabase
          .from('quotes')
          .update(quoteData)
          .eq('id', existingQuoteId)
          .select()
          .single();
      } else {
        // Insert new quote
        console.log('➕ Creating new quote');
        result = await supabase
          .from('quotes')
          .insert(quoteData)
          .select()
          .single();
      }

      if (result.error) {
        console.error('Database error saving draft:', result.error);
        toast({
          title: "Fout bij opslaan",
          description: `Kon concept niet opslaan: ${result.error.message || 'Onbekende database fout'}`,
          variant: "destructive",
        });
        return false;
      }

      console.log('✅ Quote saved successfully:', result.data?.id);
      toast({
        title: "Concept opgeslagen",
        description: `Offerte ${values.quoteNumber} is opgeslagen als concept.`,
      });
      
      if (closeAfter) {
        onClose();
      }
      return result.data?.id || true;
    } catch (error: any) {
      console.error('Unexpected error saving draft:', error);
      toast({
        title: "Fout",
        description: `Er is een onverwachte fout opgetreden: ${error.message || 'Probeer het opnieuw'}`,
        variant: "destructive",
      });
      return false;
    } finally {
      setSaving(false);
    }
  }, [customers, projects, adminSignature, toast, blocks, onClose]);

  const saveAndPrepareToSend = useCallback(async (values: z.infer<typeof formSchema>, existingQuoteId?: string) => {
    setSaving(true);
    
    try {
      // Validation
      const errors = [];
      if (!values.customer) errors.push("Selecteer eerst een klant");
      if (!values.quoteNumber) errors.push("Offertenummer ontbreekt");
      if (blocks.length === 0) errors.push("Voeg ten minste één blok toe");
      
      const blocksWithItems = blocks.filter(block => 
        block.type === 'textblock' || (block.items && block.items.length > 0)
      );
      if (blocksWithItems.length === 0) errors.push("Voeg items toe aan de blokken");
      
      if (errors.length > 0) {
        toast({
          title: "Validatie fouten",
          description: errors.join(". "),
          variant: "destructive",
        });
        setSaving(false);
        return;
      }

      const customer = customers.find(c => c.id === values.customer);
      const project = projects?.find(p => p.id === values.project);

      // Check if customer has email for sending
      const finalEmail = values.customerEmail || customer?.email || '';
      if (!finalEmail) {
        toast({
          title: "Email vereist",
          description: "Een geldig email adres van de klant is vereist om de offerte te versturen.",
          variant: "destructive",
        });
        setSaving(false);
        return;
      }

      // Generate token if not exists
      let tokenData = null;
      try {
        const { data, error: tokenError } = await supabase.rpc('generate_quote_public_token');
        tokenData = tokenError ? `quote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` : data;
      } catch {
        tokenData = `quote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      const currentTotalAmount = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
      const currentTotalVAT = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
      const currentGrandTotal = currentTotalAmount + currentTotalVAT;

      const quoteData = {
        quote_number: values.quoteNumber,
        customer_name: customer?.name || '',
        customer_email: finalEmail,
        project_title: project?.title || '',
        quote_date: values.date,
        valid_until: values.validUntil,
        message: values.message || '',
        items: JSON.parse(JSON.stringify(blocks)),
        payment_terms: JSON.stringify(paymentTerms),
        attachments: JSON.stringify(attachments),
        subtotal: currentTotalAmount,
        vat_amount: currentTotalVAT,
        total_amount: currentGrandTotal,
        status: 'te-versturen',
        public_token: tokenData,
        admin_signature_data: adminSignature || null,
        updated_at: new Date().toISOString()
      };

      let result;
      if (existingQuoteId) {
        // Update existing quote
        console.log('🔄 Updating existing quote for send:', existingQuoteId);
        result = await supabase
          .from('quotes')
          .update(quoteData)
          .eq('id', existingQuoteId)
          .select()
          .single();
      } else {
        // Insert new quote
        console.log('➕ Creating new quote for send');
        result = await supabase
          .from('quotes')
          .insert(quoteData)
          .select()
          .single();
      }

      if (result.error) {
        console.error('Database error saving quote for send:', result.error);
        toast({
          title: "Fout bij opslaan",
          description: `Database fout: ${result.error.message || 'Kon offerte niet opslaan voor verzending'}`,
          variant: "destructive",
        });
        setSaving(false);
        return;
      }

      console.log('✅ Quote prepared for sending:', result.data.id);
      
      // Navigate to send page instead of opening dialog
      toast({
        title: "Offerte opgeslagen",
        description: "Offerte is klaar om te versturen.",
      });
      
      navigate(`/quotes/${result.data.id}/send`);

    } catch (error: any) {
      console.error('Error preparing quote for send:', error);
      toast({
        title: "Kritieke fout",
        description: `Onverwachte fout: ${error.message}`,
        variant: "destructive",
      });
      setSaving(false);
    } finally {
      setSaving(false);
    }
  }, [customers, projects, adminSignature, toast, blocks, paymentTerms, attachments, navigate]);

  const handleSaveAsTemplate = async (templateData: {
    name: string;
    description?: string;
    category: string;
  }) => {
    try {
      await saveTemplate({
        ...templateData,
        template_data: blocks,
      });
      toast({
        title: "Template opgeslagen",
        description: `Template "${templateData.name}" is opgeslagen.`,
      });
    } catch (error) {
      // Error already handled in saveTemplate
    }
  };

  const handleLoadTemplate = (template: any) => {
    setBlocks(template.template_data || []);
    toast({
      title: "Succes",
      description: `Template "${template.name}" geladen`,
    });
  };

  const handleSaveDraft = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    e.stopPropagation();
    form.handleSubmit((values) => saveAsDraft(values, false, savedQuote?.id))();
  }, [form, saveAsDraft, savedQuote?.id]);

  const handleSaveAndSend = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    e.stopPropagation();
    form.handleSubmit((values) => saveAndPrepareToSend(values, savedQuote?.id))();
  }, [form, saveAndPrepareToSend, savedQuote?.id]);

  const handleExitWithConfirm = () => {
    // Check if there are unsaved changes
    const formValues = form.getValues();
    const hasContent = blocks.length > 0 || formValues.customer || formValues.message;
    
    if (hasContent && !savedQuote) {
      if (confirm('Er zijn niet-opgeslagen wijzigingen. Weet je zeker dat je wilt sluiten zonder op te slaan?')) {
        onClose();
      }
    } else {
      onClose();
    }
  };

  // Get current form values only when needed
  const currentFormValues = form.getValues();
  
  const filteredProjects = projects?.filter(project => {
    const selectedCustomer = customers.find(c => c.id === currentFormValues.customer);
    return selectedCustomer && project.customer === selectedCustomer.name;
  }) || [];

  const handleCustomerAdded = (customerId: string) => {
    console.log('Customer added, setting customerId to:', customerId);
    form.setValue('customer', customerId);
    setShowCustomerAdd(false);
    
    // Wait a bit for the data to refresh, then update email if available
    setTimeout(() => {
      const customer = customers.find(c => c.id === customerId);
      if (customer?.email) {
        form.setValue('customerEmail', customer.email);
      }
    }, 500);
  };

  const handleProjectAdded = (projectId: string) => {
    console.log('Project added, setting projectId to:', projectId);
    form.setValue('project', projectId);
    setShowProjectAdd(false);
    
    // Wait a bit for the data to refresh, then update project details
    setTimeout(() => {
      const project = projects.find(p => p.id === projectId);
      if (project) {
        // Project title is automatically filled in the form preview
        console.log('Found new project:', project.title);
      }
    }, 500);
  };

  // Watch customer changes to auto-fill email
  const selectedCustomerId = form.watch('customer');
  React.useEffect(() => {
    if (selectedCustomerId) {
      const customer = customers.find(c => c.id === selectedCustomerId);
      if (customer?.email && !form.getValues('customerEmail')) {
        form.setValue('customerEmail', customer.email);
      }
    }
  }, [selectedCustomerId, customers, form]);

  // Create preview quote object - only update when blocks change, not on every form field change
  const previewQuote: Quote = useMemo(() => {
    const formValues = form.getValues();
    const quote = {
      quote_number: formValues.quoteNumber || `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`,
      customer_name: customers.find(c => c.id === formValues.customer)?.name || '',
      customer_email: formValues.customerEmail || customers.find(c => c.id === formValues.customer)?.email || '',
      project_title: projects?.find(p => p.id === formValues.project)?.title || '',
      quote_date: formValues.date || new Date().toISOString().split('T')[0],
      valid_until: formValues.validUntil || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      message: formValues.message || '',
      blocks: JSON.parse(JSON.stringify(blocks)), // Deep copy to ensure re-render
      total_amount: totalAmount,
      total_vat_amount: totalVAT,
      status: 'concept' as const,
      admin_signature_data: adminSignature
    };
    console.log('MultiBlockQuoteForm: Created preview quote with updateCounter:', updateCounter, 'previewKey:', previewKey, quote);
    return quote;
  }, [customers, projects, blocks, totalAmount, totalVAT, adminSignature, updateCounter, previewKey]);

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 max-h-[80vh] overflow-hidden">
      {/* Left side - Form */}
      <div className="space-y-4 overflow-y-auto pr-2">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium">Nieuwe offerte - Meerdere blokken</h3>
          <div className={`px-3 py-1 rounded-lg text-sm font-medium ${
            savedQuote 
              ? "bg-green-100 text-green-800" 
              : "bg-yellow-100 text-yellow-800"
          }`}>
            {savedQuote ? "✅ Opgeslagen" : "⚠️ Concept - Niet opgeslagen"}
          </div>
        </div>

        <Form {...form}>
          <div className="space-y-4">
            {/* Template Selector */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Template Laden</CardTitle>
              </CardHeader>
              <CardContent>
                <TemplateSelector
                  templates={templates}
                  onSelectTemplate={handleLoadTemplate}
                  loading={templatesLoading}
                />
              </CardContent>
            </Card>

            {/* Basic Form Fields */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Offerte Gegevens</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="grid grid-cols-1 gap-4">
                  <FormField
                    control={form.control}
                    name="customer"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Klant *</FormLabel>
                        <div className="flex gap-2">
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger>
                                <SelectValue placeholder="Selecteer klant" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {customers.map((customer) => (
                                <SelectItem key={customer.id} value={customer.id}>
                                  {customer.name}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => setShowCustomerAdd(true)}
                            className="shrink-0"
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {showCustomerAdd && (
                    <CustomerQuickAdd
                      onCustomerAdded={handleCustomerAdded}
                      onCancel={() => setShowCustomerAdd(false)}
                    />
                  )}

                  <FormField
                    control={form.control}
                    name="customerEmail"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Email klant</FormLabel>
                        <FormControl>
                          <Input {...field} type="email" placeholder="klant@example.com" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="project"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Project (optioneel)</FormLabel>
                        <div className="flex gap-2">
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger>
                                <SelectValue placeholder="Selecteer project" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {filteredProjects.map((project) => (
                                <SelectItem key={project.id} value={project.id}>
                                  {project.title}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => setShowProjectAdd(true)}
                            className="shrink-0"
                            disabled={!selectedCustomerId}
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  {showProjectAdd && selectedCustomerId && (
                    <ProjectQuickAdd
                      onProjectAdded={handleProjectAdded}
                      onCancel={() => setShowProjectAdd(false)}
                      selectedCustomerId={selectedCustomerId}
                      selectedCustomerName={customers.find(c => c.id === selectedCustomerId)?.name || ''}
                    />
                  )}
                </div>

                <div className="grid grid-cols-3 gap-4">
                  <FormField
                    control={form.control}
                    name="quoteNumber"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Offertenummer *</FormLabel>
                        <FormControl>
                          <Input {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="date"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Datum *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="validUntil"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Geldig tot *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="message"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Bericht (optioneel)</FormLabel>
                      <FormControl>
                        <Textarea {...field} placeholder="Voeg een persoonlijk bericht toe..." />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            {/* Quote Blocks */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>Offerte Blokken</CardTitle>
                  <div className="flex gap-2">
                    <Button 
                      type="button" 
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        addBlock();
                      }} 
                      size="sm"
                    >
                      <Plus className="h-4 w-4 mr-2" />
                      Blok toevoegen
                    </Button>
                    <Button 
                      type="button" 
                      onClick={(e) => {
                        e.preventDefault();  
                        e.stopPropagation();
                        addTextBlock();
                      }} 
                      size="sm"
                      variant="outline"
                    >
                      <Plus className="h-4 w-4 mr-2" />
                      Tekstblok toevoegen
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                <DragDropContext onDragEnd={handleDragEnd}>
                  <Droppable droppableId="quote-blocks">
                    {(provided) => (
                      <div 
                        {...provided.droppableProps}
                        ref={provided.innerRef}
                        className="space-y-3"
                      >
                        {blocks.map((block, index) => (
                          <Draggable key={block.id} draggableId={block.id} index={index}>
                            {(provided, snapshot) => (
                              <div
                                ref={provided.innerRef}
                                {...provided.draggableProps}
                                className={`${snapshot.isDragging ? 'opacity-50' : ''}`}
                              >
                                <QuoteBlockForm
                                  key={`${block.id}-${updateCounter}-${previewKey}`}
                                  block={block}
                                  onUpdateBlock={(updatedBlock) => updateBlock(index, updatedBlock)}
                                  onDeleteBlock={() => deleteBlock(index)}
                                  canDelete={blocks.length > 1}
                                  dragHandleProps={provided.dragHandleProps}
                                />
                              </div>
                            )}
                          </Draggable>
                        ))}
                        {provided.placeholder}
                      </div>
                    )}
                  </Droppable>
                </DragDropContext>

                {/* Grand Total */}
                <Card className="bg-gray-50">
                  <CardContent className="p-3">
                    <div className="flex justify-end">
                      <div className="w-64 space-y-1">
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal excl. BTW:</span>
                          <span className="font-medium">€{totalAmount.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal BTW:</span>
                          <span className="font-medium">€{totalVAT.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between py-2 border-t-2 border-gray-300">
                          <span className="font-bold text-lg">Eindtotaal:</span>
                          <span className="font-bold text-lg text-smans-primary">
                            €{grandTotal.toFixed(2)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </CardContent>
            </Card>

            {/* Payment Terms */}
            <PaymentTermsSelector
              value={paymentTerms}
              onChange={setPaymentTerms}
            />

            {/* File Attachments */}
            <FileAttachmentsManager
              value={attachments}
              onChange={setAttachments}
            />

            {/* Admin Signature */}
            <Card>
              <CardHeader>
                <CardTitle>Handtekening Administratie</CardTitle>
              </CardHeader>
              <CardContent>
                <SignatureCanvas
                  onSignature={setAdminSignature}
                  title="Handtekening Administratie"
                />
              </CardContent>
            </Card>

            <div className="flex justify-end gap-2">
              <Button type="button" variant="outline" onClick={handleExitWithConfirm}>
                Annuleren
              </Button>
              <Button 
                type="button" 
                variant="outline" 
                onClick={() => {
                  const templateName = prompt('Naam voor template:');
                  if (templateName) {
                    handleSaveAsTemplate({
                      name: templateName,
                      category: 'general'
                    });
                  }
                }}
                disabled={blocks.length === 0}
              >
                <BookmarkPlus className="mr-2 h-4 w-4" />
                Opslaan als Template
              </Button>
              <Button 
                type="button" 
                variant="secondary"
                onClick={handleSaveDraft}
                disabled={saving}
                className="min-w-[140px]"
              >
                <Save className="h-4 w-4 mr-2" />
                {saving ? "Opslaan..." : "Opslaan als Concept"}
              </Button>
              <Button 
                type="button"
                onClick={handleSaveAndSend}
                disabled={saving}
                className="bg-blue-600 hover:bg-blue-700 text-white min-w-[160px]"
              >
                <Save className="h-4 w-4 mr-2" />
                {saving ? "Opslaan..." : "Opslaan en Versturen"}
              </Button>
            </div>
          </div>
        </Form>
      </div>

      {/* Right side - Live Preview */}
      <div className="overflow-y-auto pl-2">
        <div className="sticky top-0 bg-white z-10 pb-2 mb-4 border-b">
          <h4 className="font-medium text-gray-700">Live Preview</h4>
          <p className="text-xs text-yellow-600 font-medium">⚠️ Dit is alleen een preview - offerte wordt pas opgeslagen bij 'Offerte Opslaan'</p>
        </div>
        <MultiBlockQuotePreview key={previewKey} quote={previewQuote} />
      </div>

    </div>
  );
};
