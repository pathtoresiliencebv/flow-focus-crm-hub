
import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useNavigate } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd';
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription } from "@/components/ui/sheet";
import { Plus, Save, BookmarkPlus, Eye } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { QuoteBlockForm } from './QuoteBlockForm';
import { MultiBlockQuotePreview } from './MultiBlockQuotePreview';
import { SignatureCanvas } from '../SignatureCanvas';
import { CustomerQuickAdd } from '../CustomerQuickAdd';
import { ProjectQuickAdd } from '../ProjectQuickAdd';
import { TemplateSelector } from './TemplateSelector';
import { PaymentTermsSelector, PaymentTerm } from './PaymentTermsSelector';
import { FileAttachmentsManager, QuoteAttachment } from './FileAttachmentsManager';

import { RichTextEditor } from './RichTextEditor';
import { useCrmStore } from '@/hooks/useCrmStore';
import { useQuoteTemplates } from '@/hooks/useQuoteTemplates';
import { useQuoteSettings } from '@/hooks/useQuoteSettings';
import { useAuth } from '@/contexts/AuthContext';
import { QuoteBlock, Quote } from '@/types/quote';
import { supabase } from '@/integrations/supabase/client';
import { SearchableCustomerSelect } from '@/components/ui/searchable-customer-select';
import { SearchableProjectSelect } from '@/components/ui/searchable-project-select';

const formSchema = z.object({
  customer: z.string().min(1, { message: "Selecteer een klant" }),
  quoteNumber: z.string().min(1, { message: "Offertenummer is verplicht" }),
  date: z.string().min(1, { message: "Datum is verplicht" }),
  validUntil: z.string().min(1, { message: "Geldig tot datum is verplicht" }),
  project: z.string().optional(),
  message: z.string().optional(),
});

interface MultiBlockQuoteFormProps {
  onClose: () => void;
  existingQuote?: Quote;
}

export const MultiBlockQuoteForm: React.FC<MultiBlockQuoteFormProps> = ({
  onClose,
  existingQuote
}) => {
  const { customers, projects, isLoading: crmLoading, addCustomer } = useCrmStore();
  const { user } = useAuth();
  
  // DEBUG: Log customers data - only log once on mount
  React.useEffect(() => {
    if (!crmLoading) {
      console.log('üîç MultiBlockQuoteForm: CRM Loading:', crmLoading);
      console.log('üîç MultiBlockQuoteForm: Customers:', customers);
      console.log('üîç MultiBlockQuoteForm: Customers count:', customers?.length);
      console.log('üîç MultiBlockQuoteForm: Customers sample:', customers?.slice(0, 3));
    }
  }, [crmLoading]); // ‚úÖ Only depend on loading state, not customers array
  
  const { toast } = useToast();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [blocks, setBlocks] = useState<QuoteBlock[]>([
    {
      id: crypto.randomUUID(),
      title: 'Hoofdwerkzaamheden',
      type: 'product',
      items: [],
      subtotal: 0,
      vat_amount: 0,
      order_index: 0
    }
  ]);
  const [adminSignature, setAdminSignature] = useState('');
  const [saving, setSaving] = useState(false);
  const [updateCounter, setUpdateCounter] = useState(0);
  const [previewKey, setPreviewKey] = useState(0);
  const [showCustomerAdd, setShowCustomerAdd] = useState(false);
  const [showProjectAdd, setShowProjectAdd] = useState(false);
  const [savedQuote, setSavedQuote] = useState<Quote | null>(null);
  const [paymentTerms, setPaymentTerms] = useState<PaymentTerm[]>([
    { id: crypto.randomUUID(), percentage: 100, description: "Volledige betaling" }
  ]);
  const [attachments, setAttachments] = useState<QuoteAttachment[]>([]);
  
  const { templates, loading: templatesLoading, saveTemplate } = useQuoteTemplates();
  const { settings: quoteSettings, loading: quoteSettingsLoading } = useQuoteSettings();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      customer: "",
      quoteNumber: "", // Will be generated by database function
      date: new Date().toISOString().split('T')[0],
      validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      project: "",
      message: "",
    },
  });

  // Initialize form with existing quote data or generate new quote number
  // ‚úÖ Use ref to track initialization and prevent infinite loops
  const isInitialized = useRef(false);
  
  useEffect(() => {
    // Only proceed if CRM data is loaded
    if (crmLoading) return;
    
    // Only initialize once
    if (isInitialized.current) return;
    
    if (existingQuote) {
      console.log('üìù Loading existing quote:', existingQuote.id);
      console.log('üìù Customer ID from quote:', existingQuote.customer_id);
      console.log('üìù Project ID from quote:', existingQuote.project_id);
      
      // ‚úÖ FIX: Use actual customer_id and project_id from existingQuote
      form.reset({
        customer: existingQuote.customer_id || '',
        quoteNumber: existingQuote.quote_number,
        date: existingQuote.quote_date,
        validUntil: existingQuote.valid_until,
        project: existingQuote.project_id || '',
        message: existingQuote.message || '',
      });
      
      // Set blocks
      if (existingQuote.blocks && existingQuote.blocks.length > 0) {
        setBlocks(existingQuote.blocks);
      }
      
      // Set admin signature
      if (existingQuote.admin_signature_data) {
        setAdminSignature(existingQuote.admin_signature_data);
      }
      
      // Set attachments
      if (existingQuote.attachments) {
        setAttachments(Array.isArray(existingQuote.attachments) ? existingQuote.attachments : []);
      }
      
      isInitialized.current = true;
    } else {
        // Generate unique quote number for new quotes
      const generateQuoteNumber = async () => {
        try {
          console.log('üî¢ Generating new quote number...');
          
          // Use the improved database function (now with advisory locking)
          const { data, error } = await supabase.rpc('generate_quote_number');
          
          if (error) {
            console.error('‚ùå Database function error:', error);
            throw error;
          }
          
          if (data) {
            console.log('‚úÖ Generated quote number:', data);
            
            // Double-check uniqueness (extra safety)
            const { data: existing, error: checkError } = await supabase
              .from('quotes')
              .select('id')
              .eq('quote_number', data)
              .maybeSingle();
            
            if (checkError) {
              console.warn('‚ö†Ô∏è Error checking uniqueness:', checkError);
              // Still use the number since database function should handle uniqueness
            }
            
            if (existing) {
              console.error('‚ùå Quote number already exists:', data);
              // Fallback to timestamp-based number with random suffix
              const fallbackNumber = `OFF-${new Date().getFullYear()}-${Date.now().toString().slice(-4)}-${Math.random().toString(36).substr(2, 3).toUpperCase()}`;
              console.log('üîÑ Using fallback number:', fallbackNumber);
              form.setValue('quoteNumber', fallbackNumber);
            } else {
              form.setValue('quoteNumber', data);
            }
          } else {
            throw new Error('No quote number returned from database function');
          }
        } catch (err) {
          console.error('‚ùå Error generating quote number:', err);
          // Generate robust fallback quote number with timestamp and random suffix
          const fallbackNumber = `OFF-${new Date().getFullYear()}-${Date.now().toString().slice(-4)}-${Math.random().toString(36).substr(2, 3).toUpperCase()}`;
          console.log('üîÑ Using fallback number:', fallbackNumber);
          form.setValue('quoteNumber', fallbackNumber);
        }
      };
      generateQuoteNumber();
      isInitialized.current = true;
    }
  }, [existingQuote, crmLoading]); // ‚úÖ Removed 'form' from dependencies

  // Add default attachments for new quotes (only once)
  const attachmentsInitialized = useRef(false);
  useEffect(() => {
    if (attachmentsInitialized.current) return;
    
    console.log('üìé MultiBlockQuoteForm: Checking default attachments...', {
      existingQuote: !!existingQuote,
      quoteSettings: quoteSettings,
      defaultAttachments: quoteSettings?.default_attachments,
      quoteSettingsLoading
    });

    if (!existingQuote && quoteSettings?.default_attachments && !quoteSettingsLoading) {
      const defaultAttachments = Array.isArray(quoteSettings.default_attachments) 
        ? quoteSettings.default_attachments 
        : [];
      
      if (defaultAttachments.length > 0) {
        console.log('‚úÖ MultiBlockQuoteForm: Adding default attachments:', defaultAttachments);
        setAttachments(defaultAttachments);
        attachmentsInitialized.current = true;
      } else {
        // Mark as initialized even if no attachments to prevent re-running
        attachmentsInitialized.current = true;
      }
    } else if (!quoteSettingsLoading) {
      // Mark as initialized if settings are loaded but no attachments needed
      attachmentsInitialized.current = true;
    }
  }, [existingQuote, quoteSettingsLoading]); // ‚úÖ Removed quoteSettings object from dependencies

  // Remove continuous auto-save - now using blur-based saving

  const forcePreviewUpdate = useCallback(() => {
    console.log('MultiBlockQuoteForm: Forcing preview update');
    setPreviewKey(prev => prev + 1);
  }, []);

  const addBlock = useCallback(() => {
    setBlocks(prevBlocks => {
      const newBlock: QuoteBlock = {
        id: crypto.randomUUID(),
        title: `Blok ${prevBlocks.length + 1}`,
        type: 'product',
        items: [],
        subtotal: 0,
        vat_amount: 0,
        order_index: prevBlocks.length
      };
      console.log('MultiBlockQuoteForm: Adding new block:', newBlock);
      const newBlocks = [...prevBlocks, newBlock];
      console.log('MultiBlockQuoteForm: New blocks state:', newBlocks);
      return newBlocks;
    });
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const addTextBlock = useCallback(() => {
    setBlocks(prevBlocks => {
      const newTextBlock: QuoteBlock = {
        id: crypto.randomUUID(),
        title: 'Tekstblok',
        type: 'textblock',
        items: [],
        subtotal: 0,
        vat_amount: 0,
        order_index: prevBlocks.length,
        content: ''
      };
      console.log('MultiBlockQuoteForm: Adding new text block:', newTextBlock);
      const newBlocks = [...prevBlocks, newTextBlock];
      console.log('MultiBlockQuoteForm: New blocks state:', newBlocks);
      return newBlocks;
    });
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const updateBlock = useCallback((index: number, updatedBlock: QuoteBlock) => {
    console.log('MultiBlockQuoteForm: Updating block at index', index, 'with block:', updatedBlock);
    console.log('MultiBlockQuoteForm: Updated block items:', updatedBlock.items);
    
    setBlocks(prevBlocks => {
      if (index < 0 || index >= prevBlocks.length) {
        console.error('Invalid block index:', index);
        return prevBlocks;
      }
      
      const newBlocks = [...prevBlocks];
      newBlocks[index] = { 
        ...updatedBlock,
        id: prevBlocks[index].id, // Preserve original ID
        order_index: prevBlocks[index].order_index // Preserve order
      };
      
      console.log('MultiBlockQuoteForm: New blocks state after update:', newBlocks);
      console.log('MultiBlockQuoteForm: Updated block items:', newBlocks[index].items);
      return newBlocks;
    });
    
    // Update preview without forcing component remount
    setPreviewKey(prev => prev + 1);
  }, [forcePreviewUpdate]);

  const deleteBlock = useCallback((index: number) => {
    setBlocks(prevBlocks => {
      if (prevBlocks.length > 1) {
        console.log('MultiBlockQuoteForm: Deleting block at index:', index);
        const newBlocks = prevBlocks.filter((_, i) => i !== index);
        console.log('MultiBlockQuoteForm: Blocks after deletion:', newBlocks);
        return newBlocks;
      }
      return prevBlocks;
    });
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const handleDragEnd = useCallback((result: DropResult) => {
    if (!result.destination) {
      return;
    }

    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;

    if (sourceIndex === destinationIndex) {
      return;
    }

    setBlocks(prevBlocks => {
      const newBlocks = Array.from(prevBlocks);
      const [reorderedBlock] = newBlocks.splice(sourceIndex, 1);
      newBlocks.splice(destinationIndex, 0, reorderedBlock);
      
      // Update order indices
      return newBlocks.map((block, index) => ({
        ...block,
        order_index: index
      }));
    });
    
    forcePreviewUpdate();
  }, [forcePreviewUpdate]);

  const totalAmount = useMemo(() => {
    const total = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total amount:', total, 'from blocks:', blocks);
    return total;
  }, [updateCounter]); // ‚úÖ Removed blocks - will recalculate when updateCounter changes

  const totalVAT = useMemo(() => {
    const vat = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
    console.log('MultiBlockQuoteForm: Calculated total VAT:', vat, 'from blocks:', blocks);
    return vat;
  }, [updateCounter]); // ‚úÖ Removed blocks - will recalculate when updateCounter changes

  const grandTotal = useMemo(() => {
    const grand = totalAmount + totalVAT;
    console.log('MultiBlockQuoteForm: Calculated grand total:', grand);
    return grand;
  }, [totalAmount, totalVAT]);

  // Effect to monitor blocks changes for debugging
  useEffect(() => {
    console.log('MultiBlockQuoteForm: Blocks state changed:', blocks);
    console.log('MultiBlockQuoteForm: Total calculations - Amount:', totalAmount, 'VAT:', totalVAT, 'Grand:', grandTotal);
  }, [updateCounter, totalAmount, totalVAT, grandTotal]); // ‚úÖ Removed blocks - use updateCounter instead

  const saveAsDraft = useCallback(async (values: z.infer<typeof formSchema>, closeAfter: boolean = true, quoteId?: string) => {
    setSaving(true);
    
    try {
      const customer = customers.find(c => c.id === values.customer);
      const project = projects?.find(p => p.id === values.project);
      
      const currentTotalAmount = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
      const currentTotalVAT = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
      const currentGrandTotal = currentTotalAmount + currentTotalVAT;
      
      const quoteData = {
        quote_number: values.quoteNumber,
        customer_id: values.customer || null,
        customer_name: customer?.name || '',
        customer_email: customer?.email || '',
        project_id: values.project || null,
        project_title: project?.title || '',
        quote_date: values.date,
        valid_until: values.validUntil,
        message: values.message || '',
        items: JSON.parse(JSON.stringify(blocks)),
        subtotal: currentTotalAmount,
        vat_amount: currentTotalVAT,
        total_amount: currentGrandTotal,
        status: 'concept',
        admin_signature_data: adminSignature || null,
        user_id: user?.id || null,
        updated_at: new Date().toISOString()
      };
      
      console.log('üíæ Saving quote with customer data:', {
        customer_id: values.customer,
        customer_name: customer?.name,
        customer_email: customer?.email
      });

      const quoteToUpdate = quoteId || existingQuote?.id;
      let result;
      if (quoteToUpdate) {
        // Update existing quote
        console.log('üîÑ Updating existing quote:', quoteToUpdate);
        result = await supabase
          .from('quotes')
          .update(quoteData)
          .eq('id', quoteToUpdate)
          .select()
          .single();
      } else {
        // Insert new quote
        console.log('‚ûï Creating new quote');
        result = await supabase
          .from('quotes')
          .insert(quoteData)
          .select()
          .single();
      }

      if (result.error) {
        console.error('Database error saving draft:', result.error);
        
        // Handle duplicate quote number error specifically
        if (result.error.message?.includes('duplicate key value') || 
            result.error.message?.includes('quotes_quote_number_key')) {
          // Generate new quote number and retry
          const newQuoteNumber = `OFF-${new Date().getFullYear()}-${Date.now().toString().slice(-6)}`;
          const retryData = { ...quoteData, quote_number: newQuoteNumber };
          
          const retryResult = quoteToUpdate 
            ? await supabase.from('quotes').update(retryData).eq('id', quoteToUpdate).select().single()
            : await supabase.from('quotes').insert(retryData).select().single();
            
          if (retryResult.error) {
            toast({
              title: "Fout bij opslaan",
              description: "Kon concept niet opslaan. Probeer het opnieuw.",
              variant: "destructive",
            });
            return false;
          } else {
            form.setValue('quoteNumber', newQuoteNumber);
            return retryResult.data?.id || true;
          }
        } else {
          toast({
            title: "Fout bij opslaan",
            description: `Kon concept niet opslaan: ${result.error.message || 'Onbekende database fout'}`,
            variant: "destructive",
          });
          return false;
        }
      }

      console.log('‚úÖ Quote saved successfully:', result.data?.id);
      toast({
        title: "Concept opgeslagen",
        description: `Offerte ${values.quoteNumber} is opgeslagen als concept.`,
      });
      
      if (closeAfter) {
        onClose();
      }
      return result.data?.id || true;
    } catch (error: any) {
      console.error('Unexpected error saving draft:', error);
      toast({
        title: "Fout",
        description: `Er is een onverwachte fout opgetreden: ${error.message || 'Probeer het opnieuw'}`,
        variant: "destructive",
      });
      return false;
    } finally {
      setSaving(false);
    }
  }, [customers, projects, adminSignature, toast, onClose]); // ‚úÖ Removed blocks - accessed via closure

  // Blur-based auto-save with debouncing
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<number | null>(null);
  const [lastSaveData, setLastSaveData] = useState<string>('');
  
  const triggerAutoSave = useCallback(async () => {
    const formValues = form.getValues();
    const currentData = JSON.stringify({ ...formValues, blocks, adminSignature });
    
    // Only save if data has changed
    if (currentData === lastSaveData) return;
    
    // Check if there's sufficient data to save
    if (formValues.customer && formValues.quoteNumber && blocks.length > 0) {
      try {
        const savedId = await saveAsDraft(formValues, false);
        if (savedId) {
          setLastSaveData(currentData);
          console.log('‚úÖ Auto-save completed');
        }
      } catch (error) {
        console.error('Auto-save failed:', error);
        // Don't show error toast for auto-save failures to avoid spam
      }
    }
  }, [form, adminSignature, saveAsDraft, lastSaveData]); // ‚úÖ Removed blocks - accessed via closure

  const scheduleAutoSave = useCallback(() => {
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }
    
    const newTimeout = setTimeout(triggerAutoSave, 1500); // 1.5 second delay
    setAutoSaveTimeout(newTimeout);
  }, [triggerAutoSave, autoSaveTimeout]);

  // Handle field blur events
  const handleFieldBlur = useCallback(() => {
    scheduleAutoSave();
  }, [scheduleAutoSave]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }
    };
  }, [autoSaveTimeout]);

  // Navigation protection - prevent data loss
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      const formValues = form.getValues();
      
      // Check if there's unsaved data
      if (formValues.customer && formValues.quoteNumber && blocks.length > 0) {
        // Auto-save before unload
        saveAsDraft && saveAsDraft(formValues, false).catch(console.error);
        
        // Show browser warning
        e.preventDefault();
        e.returnValue = 'Je hebt niet-opgeslagen wijzigingen. Weet je zeker dat je wilt vertrekken?';
        return e.returnValue;
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, []); // ‚úÖ Empty deps - event handler accesses latest values via closure

  const saveAndPrepareToSend = useCallback(async (values: z.infer<typeof formSchema>, quoteId?: string) => {
    setSaving(true);
    
    try {
      // Validation
      const errors = [];
      if (!values.customer) errors.push("Selecteer eerst een klant");
      if (!values.quoteNumber) errors.push("Offertenummer ontbreekt");
      if (blocks.length === 0) errors.push("Voeg ten minste √©√©n blok toe");
      
      const blocksWithItems = blocks.filter(block => 
        block.type === 'textblock' || (block.items && block.items.length > 0)
      );
      if (blocksWithItems.length === 0) errors.push("Voeg items toe aan de blokken");
      
      if (errors.length > 0) {
        toast({
          title: "Validatie fouten",
          description: errors.join(". "),
          variant: "destructive",
        });
        setSaving(false);
        return;
      }

      const customer = customers.find(c => c.id === values.customer);
      const project = projects?.find(p => p.id === values.project);

      // Customer email will be requested in send dialog

      // Generate token if not exists
      let tokenData = null;
      try {
        const { data, error: tokenError } = await supabase.rpc('generate_quote_public_token');
        tokenData = tokenError ? `quote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` : data;
      } catch {
        tokenData = `quote_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      const currentTotalAmount = blocks.reduce((sum, block) => sum + (block.subtotal || 0), 0);
      const currentTotalVAT = blocks.reduce((sum, block) => sum + (block.vat_amount || 0), 0);
      const currentGrandTotal = currentTotalAmount + currentTotalVAT;

      const quoteData = {
        quote_number: values.quoteNumber,
        customer_id: values.customer || null,
        customer_name: customer?.name || '',
        customer_email: customer?.email || '',
        project_id: values.project || null,
        project_title: project?.title || '',
        quote_date: values.date,
        valid_until: values.validUntil,
        message: values.message || '',
        items: JSON.parse(JSON.stringify(blocks)),
        payment_terms: JSON.stringify(paymentTerms),
        attachments: JSON.stringify(attachments),
        subtotal: currentTotalAmount,
        vat_amount: currentTotalVAT,
        total_amount: currentGrandTotal,
        status: 'concept',
        public_token: tokenData,
        admin_signature_data: adminSignature || null,
        user_id: user?.id || null,
        updated_at: new Date().toISOString()
      };
      
      console.log('üíæ Saving final quote with customer data:', {
        customer_id: values.customer,
        customer_name: customer?.name,
        customer_email: customer?.email
      });

      const quoteToUpdate = quoteId || existingQuote?.id;
      let result;
      if (quoteToUpdate) {
        // Update existing quote
        console.log('üîÑ Updating existing quote for send:', quoteToUpdate);
        result = await supabase
          .from('quotes')
          .update(quoteData)
          .eq('id', quoteToUpdate)
          .select()
          .single();
      } else {
        // Insert new quote
        console.log('‚ûï Creating new quote for send');
        result = await supabase
          .from('quotes')
          .insert(quoteData)
          .select()
          .single();
      }

      if (result.error) {
        console.error('Database error saving quote for send:', result.error);
        toast({
          title: "Fout bij opslaan",
          description: `Database fout: ${result.error.message || 'Kon offerte niet opslaan voor verzending'}`,
          variant: "destructive",
        });
        setSaving(false);
        return;
      }

      console.log('‚úÖ Quote prepared for sending:', result.data.id);
      
      // ‚úÖ FIX: Don't navigate immediately - close dialog and refresh quotes list
      // Navigating before quotes are refreshed causes "Authenticatie controleren" loop
      toast({
        title: "Offerte opgeslagen",
        description: "Offerte is succesvol opgeslagen en klaar om te versturen.",
      });
      
      // Close the dialog - quotes list will auto-refresh via React Query
      onClose();

    } catch (error: any) {
      console.error('Error preparing quote for send:', error);
      toast({
        title: "Kritieke fout",
        description: `Onverwachte fout: ${error.message}`,
        variant: "destructive",
      });
      setSaving(false);
    } finally {
      setSaving(false);
    }
  }, [customers, projects, adminSignature, toast, paymentTerms, attachments, onClose]); // ‚úÖ Removed blocks - accessed via closure

  const handleSaveAsTemplate = async (templateData: {
    name: string;
    description?: string;
    category: string;
  }) => {
    try {
      await saveTemplate({
        ...templateData,
        template_data: blocks,
      });
      toast({
        title: "Template opgeslagen",
        description: `Template "${templateData.name}" is opgeslagen.`,
      });
    } catch (error) {
      // Error already handled in saveTemplate
    }
  };

  const handleLoadTemplate = (template: any) => {
    setBlocks(template.template_data || []);
    toast({
      title: "Succes",
      description: `Template "${template.name}" geladen`,
    });
  };

  // Remove old auto-save - using blur-based saving now

  // Old auto-save removed - now using blur-based saving

  const handleSaveDraft = useCallback(async (e?: React.FormEvent) => {
    console.log('üíæ handleSaveDraft: START');
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    setSaving(true);
    console.log('üíæ handleSaveDraft: Saving set to true');
    
    try {
      console.log('üíæ handleSaveDraft: Getting form values...');
      const values = form.getValues();
      console.log('üíæ handleSaveDraft: Form values:', {
        customer: values.customer,
        project: values.project,
        quoteNumber: values.quoteNumber,
        blocksCount: blocks.length
      });
      
      console.log('üíæ handleSaveDraft: Calling saveAsDraft...');
      const success = await saveAsDraft(values, false);
      console.log('üíæ handleSaveDraft: saveAsDraft returned:', success);
      
      if (success) {
        console.log('‚úÖ handleSaveDraft: Success! Showing toast and closing dialog');
        toast({
          title: "Concept opgeslagen",
          description: "Je offerte is opgeslagen als concept.",
        });
        // ‚úÖ FIX: Close dialog instead of navigate to prevent auth loop
        onClose();
      } else {
        console.log('‚ö†Ô∏è handleSaveDraft: saveAsDraft returned false - NOT closing');
      }
    } catch (error) {
      console.error('‚ùå handleSaveDraft: Error:', error);
      toast({
        title: "Fout bij opslaan",
        description: "Er is een fout opgetreden bij het opslaan van het concept.",
        variant: "destructive",
      });
    } finally {
      console.log('üíæ handleSaveDraft: FINALLY - Setting saving to false');
      setSaving(false);
    }
  }, [form, saveAsDraft, toast]); // ‚úÖ Removed blocks - accessed via closure

  const handleSaveAndSend = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    setSaving(true);
    try {
      // First validate the form
      const isValid = await form.trigger();
      if (!isValid) {
        toast({
          title: "Validatie fout",
          description: "Controleer alle vereiste velden voordat je de offerte verstuurt.",
          variant: "destructive",
        });
        return;
      }

      // Get form values
      const values = form.getValues();
      
      // First save as draft
      console.log('üíæ Saving quote as draft first...');
      const success = await saveAsDraft(values, false);
      
      if (!success) {
        toast({
          title: "Fout bij opslaan",
          description: "Kon de offerte niet opslaan als concept.",
          variant: "destructive",
        });
        return;
      }

      // If we have a saved quote ID, trigger the send email function
      if (savedQuote?.id) {
        console.log('üìß Triggering send email for quote:', savedQuote.id);
        
        // Call the send-quote-email edge function directly
        const { data, error } = await supabase.functions.invoke('send-quote-email', {
          body: {
            quoteId: savedQuote.id,
            recipientEmail: values.customerEmail || customers.find(c => c.id === values.customer)?.email,
            recipientName: values.customerName || customers.find(c => c.id === values.customer)?.name,
            subject: `Offerte ${savedQuote.quote_number} - SMANS BV`,
            message: values.message || 'Hierbij ontvangt u uw offerte. Voor vragen kunt u contact met ons opnemen.'
          }
        });

        if (error) {
          console.error('‚ùå Error sending email:', error);
          toast({
            title: "Fout bij versturen",
            description: `Kon email niet versturen: ${error.message}`,
            variant: "destructive",
          });
          return;
        }

        if (data?.success) {
          toast({
            title: "Offerte verzonden!",
            description: `De offerte is succesvol verzonden naar ${data.recipientEmail}`,
          });
          
          // ‚úÖ FIX: Close dialog instead of navigate to prevent auth loop
          onClose();
        } else {
          toast({
            title: "Fout bij versturen",
            description: "Er is een onbekende fout opgetreden bij het versturen.",
            variant: "destructive",
          });
        }
      } else {
        toast({
          title: "Fout bij opslaan",
          description: "Kon de offerte ID niet ophalen na opslaan.",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error in save and send:', error);
      toast({
        title: "Fout bij opslaan en versturen",
        description: "Er is een onverwachte fout opgetreden.",
        variant: "destructive",
      });
    } finally {
      setSaving(false);
    }
  }, [form, saveAsDraft, savedQuote, customers, toast]);

  const handleExitWithConfirm = () => {
    // Check if there are unsaved changes
    const formValues = form.getValues();
    const hasContent = blocks.length > 0 || formValues.customer || formValues.message;
    
    if (hasContent && !savedQuote) {
      toast({
        title: "Niet-opgeslagen wijzigingen",
        description: "Je hebt niet-opgeslagen wijzigingen. Deze gaan verloren bij het sluiten.",
        variant: "destructive",
      });
      // Give user 3 seconds to reconsider, then close anyway
      setTimeout(() => {
        onClose();
      }, 3000);
    } else {
      onClose();
    }
  };

  // ‚úÖ FIX: Watch customer BEFORE useMemo to prevent infinite loop
  const selectedCustomerId = form.watch('customer');
  
  // Filter projects based on selected customer
  const filteredProjects = useMemo(() => {
    if (!selectedCustomerId || !projects || !customers) return [];
    
    const selectedCustomer = customers.find(c => c.id === selectedCustomerId);
    if (!selectedCustomer) return [];
    
    return projects.filter(project => project.customer === selectedCustomer.name);
  }, [selectedCustomerId, projects, customers]); // ‚úÖ Use watched value, not form.watch() call

  const handleCustomerAdded = async (customer: any) => {
    console.log('‚úÖ Customer added:', customer);
    
    try {
      // Force invalidate and refetch customers query for immediate UI update
      await queryClient.invalidateQueries({ queryKey: ['customers'] });
      
      // Small delay to ensure query refetch completes then set customer
      setTimeout(() => {
        console.log('üîÑ Setting customer in form:', customer.id);
        form.setValue('customer', customer.id);
        
        // Force form to re-validate customer field
        form.trigger('customer');
        
        toast({
          title: "Klant toegevoegd",
          description: `${customer.name} is toegevoegd en geselecteerd voor de offerte.`,
        });
      }, 300);
      
      setShowCustomerAdd(false);
      
      // Force a preview update
      forcePreviewUpdate();
    } catch (error) {
      console.error('‚ùå Error handling customer add:', error);
      toast({
        title: "Fout",
        description: "Kon klant niet selecteren. Probeer opnieuw.",
        variant: "destructive",
      });
      setShowCustomerAdd(false);
    }
  };

  const handleProjectAdded = useCallback(async (projectId: string) => {
    console.log('‚úÖ Project added, setting projectId to:', projectId);
    
    try {
      // Force invalidate and refetch projects query
      await queryClient.invalidateQueries({ queryKey: ['projects'] });
      
      // Small delay to ensure query refetch completes
      setTimeout(() => {
        console.log('üîÑ Setting project in form:', projectId);
        
        // Set the project in the form
        form.setValue('project', projectId);
        
        // Force form to re-validate project field
        form.trigger('project');
        
        // Force preview update
        forcePreviewUpdate();
        
        toast({
          title: "Project toegevoegd",
          description: "Het nieuwe project is toegevoegd en geselecteerd voor de offerte.",
        });
      }, 300);
      
      setShowProjectAdd(false);
    } catch (error) {
      console.error('‚ùå Error handling project add:', error);
      toast({
        title: "Fout",
        description: "Kon project niet selecteren. Probeer opnieuw.",
        variant: "destructive",
      });
      setShowProjectAdd(false);
    }
  }, [form, forcePreviewUpdate, toast, queryClient]);

  // Email is no longer auto-filled

  // Manual blur-based auto-save instead of continuous auto-save
  const handleFormBlur = useCallback(() => {
    const formValues = form.getValues();
    
    // Only save if we have meaningful data
    if (formValues.customer && formValues.quoteNumber && blocks.length > 0) {
      console.log('Saving on form blur...');
      saveAsDraft(formValues, false).catch(console.error);
    }
  }, [form, saveAsDraft]); // ‚úÖ Removed blocks - accessed via closure

  // Create preview quote object - only update when blocks change, not on every form field change
  const previewQuote: Quote = useMemo(() => {
    const formValues = form.getValues();
    const selectedCustomer = customers.find(c => c.id === formValues.customer);
    const selectedProject = projects?.find(p => p.id === formValues.project);
    
    const quote = {
      quote_number: formValues.quoteNumber || `OFF-${new Date().getFullYear()}-${String(Date.now()).slice(-4)}`,
      customer_name: selectedCustomer?.name || '',
      customer_email: selectedCustomer?.email || '',
      project_title: selectedProject?.title || '',
      quote_date: formValues.date || new Date().toISOString().split('T')[0],
      valid_until: formValues.validUntil || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      message: formValues.message || '',
      blocks: JSON.parse(JSON.stringify(blocks)), // Deep copy to ensure re-render
      total_amount: totalAmount,
      total_vat_amount: totalVAT,
      status: 'concept' as const,
      admin_signature_data: adminSignature
    };
    console.log('MultiBlockQuoteForm: Created preview quote with updateCounter:', updateCounter, 'previewKey:', previewKey, quote);
    return quote;
  }, [customers, projects, totalAmount, totalVAT, adminSignature, updateCounter, previewKey]); // ‚úÖ Removed blocks - accessed via closure, updates via updateCounter/previewKey

  // Show loading state if CRM data is still loading
  if (crmLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-center py-8">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p className="text-muted-foreground">Gegevens laden...</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 max-w-full">
      {/* Left side - Form - Breder gemaakt */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium">Nieuwe offerte - Meerdere blokken</h3>
          <div className={`px-3 py-1 rounded-lg text-sm font-medium ${
            savedQuote 
              ? "bg-green-100 text-green-800" 
              : "bg-yellow-100 text-yellow-800"
          }`}>
            {savedQuote ? "‚úÖ Opgeslagen" : "‚ö†Ô∏è Concept - Niet opgeslagen"}
          </div>
        </div>

        <Form {...form}>
          <div className="space-y-4">
            {/* Template Selector */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Template Laden</CardTitle>
              </CardHeader>
              <CardContent>
                <TemplateSelector
                  templates={templates}
                  onSelectTemplate={handleLoadTemplate}
                  loading={templatesLoading}
                />
              </CardContent>
            </Card>

            {/* Basic Form Fields */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Offerte Gegevens</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="grid grid-cols-1 gap-4">
                  <FormField
                    control={form.control}
                    name="customer"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Klant *</FormLabel>
                        <div className="flex gap-2">
                          <FormControl>
                            <SearchableCustomerSelect
                              customers={customers}
                              value={field.value}
                              onValueChange={field.onChange}
                              placeholder="Zoek op naam, email of telefoon..."
                              className="flex-1"
                            />
                          </FormControl>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => setShowCustomerAdd(true)}
                            className="shrink-0"
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="project"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Project (optioneel)</FormLabel>
                        <div className="flex gap-2">
                          <FormControl>
                            <SearchableProjectSelect
                              projects={filteredProjects}
                              value={field.value}
                              onValueChange={field.onChange}
                              placeholder="Zoek en selecteer project..."
                              className="flex-1"
                              disabled={!form.watch('customer')}
                            />
                          </FormControl>
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={() => setShowProjectAdd(true)}
                            className="shrink-0"
                            disabled={!form.watch('customer')}
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                        </div>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <div className="grid grid-cols-3 gap-4">
                  <FormField
                    control={form.control}
                    name="quoteNumber"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Offertenummer *</FormLabel>
                         <FormControl>
                           <Input {...field} onBlur={handleFieldBlur} />
                         </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="date"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Datum *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} onBlur={handleFieldBlur} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="validUntil"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Geldig tot *</FormLabel>
                        <FormControl>
                          <Input type="date" {...field} onBlur={handleFieldBlur} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </div>

                <FormField
                  control={form.control}
                  name="message"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Bericht (optioneel)</FormLabel>
                      <FormControl>
                        <RichTextEditor 
                          value={field.value || ''}
                          onChange={field.onChange}
                          placeholder="Voeg een persoonlijk bericht toe..."
                          onBlur={handleFieldBlur}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </CardContent>
            </Card>

            {/* Quote Blocks */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>Offerte Blokken</CardTitle>
                  <div className="flex gap-2">
                    <Button 
                      type="button" 
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        addBlock();
                      }} 
                      size="sm"
                    >
                      <Plus className="h-4 w-4 mr-2" />
                      Blok toevoegen
                    </Button>
                    <Button 
                      type="button" 
                      onClick={(e) => {
                        e.preventDefault();  
                        e.stopPropagation();
                        addTextBlock();
                      }} 
                      size="sm"
                      variant="outline"
                    >
                      <Plus className="h-4 w-4 mr-2" />
                      Tekstblok toevoegen
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                <DragDropContext onDragEnd={handleDragEnd}>
                  <Droppable droppableId="quote-blocks">
                    {(provided) => (
                      <div 
                        {...provided.droppableProps}
                        ref={provided.innerRef}
                        className="space-y-3"
                      >
                        {blocks.map((block, index) => (
                          <Draggable key={block.id} draggableId={block.id} index={index}>
                            {(provided, snapshot) => (
                              <div
                                ref={provided.innerRef}
                                {...provided.draggableProps}
                                className={`${snapshot.isDragging ? 'opacity-50' : ''}`}
                              >
                                <QuoteBlockForm
                                  key={`${block.id}-${updateCounter}-${previewKey}`}
                                  block={block}
                                  onUpdateBlock={(updatedBlock) => updateBlock(index, updatedBlock)}
                                  onDeleteBlock={() => deleteBlock(index)}
                                  canDelete={blocks.length > 1}
                                  dragHandleProps={provided.dragHandleProps}
                                />
                              </div>
                            )}
                          </Draggable>
                        ))}
                        {provided.placeholder}
                      </div>
                    )}
                  </Droppable>
                </DragDropContext>

                {/* Grand Total */}
                <Card className="bg-gray-50">
                  <CardContent className="p-3">
                    <div className="flex justify-end">
                      <div className="w-64 space-y-1">
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal excl. BTW:</span>
                          <span className="font-medium">‚Ç¨{totalAmount.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="font-medium">Totaal BTW:</span>
                          <span className="font-medium">‚Ç¨{totalVAT.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between py-2 border-t-2 border-gray-300">
                          <span className="font-bold text-lg">Eindtotaal:</span>
                          <span className="font-bold text-lg text-smans-primary">
                            ‚Ç¨{grandTotal.toFixed(2)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </CardContent>
            </Card>

            {/* Payment Terms */}
            <PaymentTermsSelector
              value={paymentTerms}
              onChange={setPaymentTerms}
            />

            {/* File Attachments */}
            <FileAttachmentsManager
              value={attachments}
              onChange={setAttachments}
            />

            {/* Admin Signature */}
            <Card>
              <CardHeader>
                <CardTitle>Handtekening Administratie</CardTitle>
              </CardHeader>
              <CardContent>
                <SignatureCanvas
                  onSignature={setAdminSignature}
                  title="Handtekening Administratie"
                />
              </CardContent>
            </Card>

            <div className="space-y-2">
              {/* Auto-save status removed - now using blur-based saving */}
              
              <div className="flex justify-end gap-2">
                <Button type="button" variant="outline" onClick={handleExitWithConfirm}>
                  Annuleren
                </Button>
                <Button 
                  type="button" 
                  variant="outline" 
                  onClick={() => {
                    // Generate a simple template name with timestamp
                    const now = new Date();
                    const timestamp = now.toLocaleString('nl-NL', { 
                      day: '2-digit', 
                      month: '2-digit', 
                      hour: '2-digit', 
                      minute: '2-digit' 
                    });
                    const templateName = `Template ${timestamp}`;
                    
                    handleSaveAsTemplate({
                      name: templateName,
                      category: 'general'
                    });
                  }}
                  disabled={blocks.length === 0}
                >
                  <BookmarkPlus className="mr-2 h-4 w-4" />
                  Opslaan als Template
                </Button>
                <Button 
                  type="button"
                  onClick={handleSaveDraft}
                  disabled={saving}
                  className="bg-blue-600 hover:bg-blue-700 text-white min-w-[140px]"
                >
                  <Save className="h-4 w-4 mr-2" />
                  {saving ? "Opslaan..." : "Opslaan"}
                </Button>
              </div>
            </div>
          </div>
        </Form>
      </div>

      {/* Right side - Preview - Breder gemaakt */}
      <div>
        <div className="flex items-center gap-2 mb-2">
          <Eye className="h-3 w-3" />
          <h4 className="text-xs font-medium text-gray-600">Preview</h4>
        </div>
        <MultiBlockQuotePreview 
          key={previewKey} 
          quote={previewQuote} 
          attachments={attachments} 
        />
      </div>

      {/* Sidebar voor nieuwe klant toevoegen */}
      <Sheet open={showCustomerAdd} onOpenChange={setShowCustomerAdd}>
        <SheetContent side="right" className="w-full sm:max-w-xl overflow-y-auto">
          <SheetHeader>
            <SheetTitle>Nieuwe Klant Toevoegen</SheetTitle>
            <SheetDescription>
              Voeg een nieuwe klant toe en selecteer deze direct voor de offerte.
            </SheetDescription>
          </SheetHeader>
          <div className="mt-6">
            <CustomerQuickAdd
              onCustomerAdded={handleCustomerAdded}
              onCancel={() => setShowCustomerAdd(false)}
            />
          </div>
        </SheetContent>
      </Sheet>

      {/* Sidebar voor nieuw project toevoegen */}
      <Sheet open={showProjectAdd} onOpenChange={setShowProjectAdd}>
        <SheetContent side="right" className="w-full sm:max-w-xl overflow-y-auto">
          <SheetHeader>
            <SheetTitle>Nieuw Project Toevoegen</SheetTitle>
            <SheetDescription>
              Voeg een nieuw project toe en selecteer deze direct voor de offerte.
            </SheetDescription>
          </SheetHeader>
          <div className="mt-6">
            {form.watch('customer') && (
              <ProjectQuickAdd
                onProjectAdded={handleProjectAdded}
                onCancel={() => setShowProjectAdd(false)}
                selectedCustomerId={form.watch('customer')}
                selectedCustomerName={customers.find(c => c.id === form.watch('customer'))?.name || ''}
              />
            )}
          </div>
        </SheetContent>
      </Sheet>
    </div>
  );
};
